import Foundation
import CoreAudio
import AVFoundation
import SwiftUI

class AudioManager: ObservableObject {
    static let shared = AudioManager()
    
    @Published private(set) var outputDevices: [AudioDevice] = []
    @Published private(set) var inputDevices: [AudioDevice] = []
    @Published private(set) var selectedOutputDevice: AudioDevice?
    @Published private(set) var selectedInputDevice: AudioDevice?
    @Published private(set) var outputVolume: Float = 0.0
    @Published private(set) var inputVolume: Float = 0.0
    @Published private(set) var outputBalance: Float = 0.0
    @Published private(set) var inputBalance: Float = 0.0
    @Published var historicalOutputDevices: [AudioDevice] = []
    @Published var historicalInputDevices: [AudioDevice] = []
    
    private var deviceListenerID: AudioObjectPropertyListenerProc?
    private var defaultInputListenerID: AudioObjectPropertyListenerProc?
    private var defaultOutputListenerID: AudioObjectPropertyListenerProc?
    private var inputVolumeListenerID: AudioObjectPropertyListenerProc?
    private var outputVolumeListenerID: AudioObjectPropertyListenerProc?
    private let settings = TunaSettings.shared
    
    private var userSelectedOutputUID: String?
    private var userSelectedInputUID: String?
    
    private var deviceListenerQueue = DispatchQueue(label: "com.tuna.deviceListener")
    private var deviceListener: AudioObjectPropertyListenerBlock?
    
    // 蓝牙设备音量轮询定时器
    private var volumePollingTimer: Timer?
    private var lastBluetoothOutputVolume: Float = -1
    private var lastBluetoothInputVolume: Float = -1
    private var isPollingForVolumeChanges = false
    
    // 新增：平衡保护定时器
    private var balanceProtectionTimer: Timer?
    private var isBalanceProtectionActive = false
    
    // 输入设备音量变化回调
    private let inputVolumeChanged: AudioObjectPropertyListenerProc = { inObjectID, inNumberAddresses, inAddresses, inClientData in
        guard let clientData = inClientData else { return noErr }
        let manager = Unmanaged<AudioManager>.fromOpaque(clientData).takeUnretainedValue()
        
        // 只在当前输入设备ID匹配时处理
        DispatchQueue.main.async {
            if let device = manager.selectedInputDevice, device.id == inObjectID {
                let oldVolume = manager.inputVolume
                let newVolume = device.getVolume()
                print("输入设备 \(device.name) 音量更新为: \(newVolume) (原音量: \(oldVolume))")
                
                // 检查音量变化是否显著（避免微小波动导致的循环更新）
                if abs(oldVolume - newVolume) > 0.001 {
                    manager.inputVolume = newVolume
                    
                    // 如果是蓝牙设备，可能需要特殊处理
                    if device.uid.lowercased().contains("bluetooth") {
                        print("蓝牙设备音量变化更新: \(device.name)")
                        // 某些蓝牙设备在音量变化时可能需要刷新平衡值
                        let balance = device.getBalance()
                        if balance != manager.inputBalance {
                            manager.inputBalance = balance
                            print("蓝牙设备 \(device.name) 平衡更新为: \(balance)")
                        }
                        
                        // 更新轮询基准值
                        manager.lastBluetoothInputVolume = newVolume
                    }
                }
            }
        }
        
        return noErr
    }
    
    // 输出设备音量变化回调
    private let outputVolumeChanged: AudioObjectPropertyListenerProc = { inObjectID, inNumberAddresses, inAddresses, inClientData in
        guard let clientData = inClientData else { return noErr }
        let manager = Unmanaged<AudioManager>.fromOpaque(clientData).takeUnretainedValue()
        
        // 只在当前输出设备ID匹配时处理
        DispatchQueue.main.async {
            if let device = manager.selectedOutputDevice, device.id == inObjectID {
                let oldVolume = manager.outputVolume
                let newVolume = device.getVolume()
                print("输出设备 \(device.name) 音量更新为: \(newVolume) (原音量: \(oldVolume))")
                
                // 检查音量变化是否显著（避免微小波动导致的循环更新）
                if abs(oldVolume - newVolume) > 0.001 {
                    manager.outputVolume = newVolume
                    
                    // 如果是蓝牙设备，可能需要特殊处理
                    if device.uid.lowercased().contains("bluetooth") {
                        print("蓝牙设备音量变化更新: \(device.name)")
                        // 某些蓝牙设备在音量变化时可能需要刷新平衡值
                        let balance = device.getBalance()
                        if balance != manager.outputBalance {
                            manager.outputBalance = balance
                            print("蓝牙设备 \(device.name) 平衡更新为: \(balance)")
                        }
                        
                        // 更新轮询基准值
                        manager.lastBluetoothOutputVolume = newVolume
                    }
                }
            }
        }
        
        return noErr
    }
    
    private init() {
        print("===== 初始化 AudioManager =====")
        
        // 首先获取设备信息和音量，确保音量初始值的准确性
        loadHistoricalDevices() // 先加载历史设备
        setupListeners()        // 设置监听器
        updateDevices()         // 更新当前设备列表
        
        // 强制使用系统API初始化音量值 (关键步骤)
        initialSystemVolumeSync()
        
        applyDefaultDeviceSettings() // 应用默认设备设置
        
        // 设置系统级音量监听器
        setupSystemAudioVolumeListener()
        
        // 设置定期轮询定时器
        startVolumePollingTimer()
        
        // 启动平衡保护系统
        startBalanceProtectionSystem()
        
        // 多阶段音量同步策略
        // 阶段1: 快速同步 (在初始化后立即)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
            self.initialSystemVolumeSync() // 再次同步确保准确性
        }
        
        // 阶段2: 短延迟后再次尝试 (给系统时间完成设备初始化)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
            self.forceBluetoothVolumeSync(highPriority: true)
        }
        
        // 阶段3: 中等延迟后的蓝牙设备专用同步
        DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
            self.forceBluetoothVolumeSync(highPriority: true)
        }
        
        // 阶段4: 最终同步尝试 (较长延迟，确保系统已完全就绪)
        DispatchQueue.main.asyncAfter(deadline: .now() + 2.0) {
            self.forceBluetoothVolumeSync(highPriority: true)
            self.forceSyncAllDevicesVolume()
        }
    }
    
    private func getAudioDevices(scope: AudioScope) -> [AudioDevice] {
        var deviceList = [AudioDevice]()
        
        // 获取所有音频设备
        var propertySize: UInt32 = 0
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        let result = AudioObjectGetPropertyDataSize(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &propertySize
        )
        
        if result != noErr {
            print("获取设备列表大小失败: \(result)")
            return []
        }
        
        let deviceCount = Int(propertySize) / MemoryLayout<AudioDeviceID>.size
        var deviceIDs = [AudioDeviceID](repeating: 0, count: deviceCount)
        
        let getDevicesResult = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &propertySize,
            &deviceIDs
        )
        
        if getDevicesResult != noErr {
            print("获取设备列表失败: \(getDevicesResult)")
            return []
        }
        
        // 处理每个设备
        for deviceID in deviceIDs {
            if let device = AudioDevice(deviceID: deviceID) {
                switch scope {
                case .input where device.hasInput:
                    deviceList.append(device)
                case .output where device.hasOutput:
                    deviceList.append(device)
                default:
                    break
                }
            }
        }
        
        return deviceList.sorted { $0.name < $1.name }
    }
    
    private func updateDeviceList() {
        let currentOutputDevices = getAudioDevices(scope: .output)
        let currentInputDevices = getAudioDevices(scope: .input)
        
        // Update current devices
        DispatchQueue.main.async {
            self.outputDevices = currentOutputDevices
            self.inputDevices = currentInputDevices
            
            // Update historical devices - add new devices to history
            self.historicalOutputDevices = Array(Set(self.historicalOutputDevices + currentOutputDevices))
                .sorted { $0.name < $1.name }
            self.historicalInputDevices = Array(Set(self.historicalInputDevices + currentInputDevices))
                .sorted { $0.name < $1.name }
            
            // Save historical devices to UserDefaults
            self.saveHistoricalDevices()
        }
    }
    
    private func saveHistoricalDevices() {
        let historicalOutputData = try? JSONEncoder().encode(historicalOutputDevices)
        let historicalInputData = try? JSONEncoder().encode(historicalInputDevices)
        
        UserDefaults.standard.set(historicalOutputData, forKey: "historicalOutputDevices")
        UserDefaults.standard.set(historicalInputData, forKey: "historicalInputDevices")
    }
    
    private func loadHistoricalDevices() {
        if let outputData = UserDefaults.standard.data(forKey: "historicalOutputDevices"),
           let outputDevices = try? JSONDecoder().decode([AudioDevice].self, from: outputData) {
            historicalOutputDevices = outputDevices
        }
        
        if let inputData = UserDefaults.standard.data(forKey: "historicalInputDevices"),
           let inputDevices = try? JSONDecoder().decode([AudioDevice].self, from: inputData) {
            historicalInputDevices = inputDevices
        }
    }
    
    private func applyDefaultDeviceSettings() {
        let settings = TunaSettings.shared
        
        // 处理输出设备
        if !settings.preferredOutputDeviceUID.isEmpty {
            // 检查首选设备是否可用
            if let preferredDevice = outputDevices.first(where: { $0.uid == settings.preferredOutputDeviceUID }) {
                print("找到首选输出设备: \(preferredDevice.name)，正在设置...")
                setDefaultDevice(preferredDevice, forInput: false)
            } else {
                print("首选输出设备不可用，使用系统默认设备")
                // 如果首选设备不可用，使用系统默认设备
                updateSelectedDevices()
            }
        } else {
            print("未设置首选输出设备，使用系统默认设备")
            updateSelectedDevices()
        }
        
        // 处理输入设备
        if !settings.preferredInputDeviceUID.isEmpty {
            // 检查首选设备是否可用
            if let preferredDevice = inputDevices.first(where: { $0.uid == settings.preferredInputDeviceUID }) {
                print("找到首选输入设备: \(preferredDevice.name)，正在设置...")
                setDefaultDevice(preferredDevice, forInput: true)
            } else {
                print("首选输入设备不可用，使用系统默认设备")
                // 如果首选设备不可用，使用系统默认设备
                updateSelectedDevices()
            }
        } else {
            print("未设置首选输入设备，使用系统默认设备")
            updateSelectedDevices()
        }
    }
    
    func updateDevices() {
        var deviceList = [AudioDevice]()
        
        // 获取所有音频设备
        var propertySize: UInt32 = 0
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        let result = AudioObjectGetPropertyDataSize(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &propertySize
        )
        
        if result != noErr {
            print("获取设备列表大小失败: \(result)")
            return
        }
        
        let deviceCount = Int(propertySize) / MemoryLayout<AudioDeviceID>.size
        var deviceIDs = [AudioDeviceID](repeating: 0, count: deviceCount)
        
        let getDevicesResult = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            &propertySize,
            &deviceIDs
        )
        
        if getDevicesResult != noErr {
            print("获取设备列表失败: \(getDevicesResult)")
            return
        }
        
        // 获取默认输入输出设备
        var defaultOutputID: AudioDeviceID = 0
        var defaultInputID: AudioDeviceID = 0
        var propsize = UInt32(MemoryLayout<AudioDeviceID>.size)
        
        var outputAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var inputAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &outputAddress,
            0,
            nil,
            &propsize,
            &defaultOutputID
        )
        
        AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &inputAddress,
            0,
            nil,
            &propsize,
            &defaultInputID
        )
        
        // 处理每个设备
        for deviceID in deviceIDs {
            if let device = AudioDevice(deviceID: deviceID) {
                deviceList.append(device)
                
                // 更新选中的设备
                if device.id == defaultOutputID {
                    selectedOutputDevice = device
                    outputVolume = device.volume
                }
                if device.id == defaultInputID {
                    selectedInputDevice = device
                    inputVolume = device.volume
                }
            }
        }
        
        DispatchQueue.main.async {
            // 更新当前设备列表
            self.outputDevices = deviceList.filter { $0.hasOutput }
            self.inputDevices = deviceList.filter { $0.hasInput }
            
            // 更新历史设备列表
            let newOutputDevices = Set(self.outputDevices)
            let newInputDevices = Set(self.inputDevices)
            
            // 合并现有的历史设备和新设备
            let updatedHistoricalOutputs = Set(self.historicalOutputDevices).union(newOutputDevices)
            let updatedHistoricalInputs = Set(self.historicalInputDevices).union(newInputDevices)
            
            // 更新历史设备列表并排序
            self.historicalOutputDevices = Array(updatedHistoricalOutputs).sorted { $0.name < $1.name }
            self.historicalInputDevices = Array(updatedHistoricalInputs).sorted { $0.name < $1.name }
            
            // 保存历史设备到 UserDefaults
            self.saveHistoricalDevices()
            
            // 检查并应用设备设置
            self.applyDefaultDeviceSettings()
        }
    }
    
    func setDefaultDevice(_ device: AudioDevice, forInput: Bool) {
        print("正在设置\(forInput ? "输入" : "输出")设备: \(device.name)")
        
        // 强制重置平衡值为中心位置
        if device.resetBalance() {
            print("切换设备前重置平衡值到中心位置成功")
        }
        
        let selector = forInput ? kAudioHardwarePropertyDefaultInputDevice : kAudioHardwarePropertyDefaultOutputDevice
        var address = AudioObjectPropertyAddress(
            mSelector: selector,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var deviceID = device.id
        let status = AudioObjectSetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            0,
            nil,
            UInt32(MemoryLayout<AudioDeviceID>.size),
            &deviceID
        )
        
        if status == noErr {
            print("成功设置\(forInput ? "输入" : "输出")设备: \(device.name)")
            // 记录用户手动选择的设备
            if forInput {
                userSelectedInputUID = device.uid
                selectedInputDevice = device
                
                // 确保获取最新音量
                let volume = directSystemVolumeQuery(device: device, isInput: true)
                inputVolume = volume
                lastBluetoothInputVolume = volume
                
                // 首先重置平衡到中心位置
                if device.resetBalance() {
                    print("已重置输入设备平衡到中心位置")
                    inputBalance = 0.0
                    
                    // 多次确保平衡值为0
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        if device.resetBalance() {
                            print("再次确认输入设备平衡已重置")
                            self.inputBalance = 0.0
                        }
                    }
                } else {
                    // 如果重置失败，获取当前平衡值
                    inputBalance = device.getBalance()
                    print("重置平衡失败，当前平衡值: \(inputBalance)")
                }
                
                // 检查是否为蓝牙设备，如果是则进行额外的音量同步
                if device.uid.lowercased().contains("bluetooth") {
                    print("检测到切换到蓝牙输入设备，进行额外的音量同步")
                    // 延迟执行以确保系统有时间更新设备状态
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        self.syncBluetoothDeviceVolume(device: device, isInput: true)
                        
                        // 再次重置平衡值
                        if device.resetBalance() {
                            print("蓝牙设备同步后重置平衡")
                            self.inputBalance = 0.0
                        }
                    }
                }
            } else {
                userSelectedOutputUID = device.uid
                selectedOutputDevice = device
                
                // 确保获取最新音量
                let volume = directSystemVolumeQuery(device: device, isInput: false)
                outputVolume = volume
                lastBluetoothOutputVolume = volume
                
                // 首先重置平衡到中心位置
                if device.resetBalance() {
                    print("已重置输出设备平衡到中心位置")
                    outputBalance = 0.0
                    
                    // 多次确保平衡值为0
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        if device.resetBalance() {
                            print("再次确认输出设备平衡已重置")
                            self.outputBalance = 0.0
                        }
                    }
                } else {
                    // 如果重置失败，获取当前平衡值
                    outputBalance = device.getBalance()
                    print("重置平衡失败，当前平衡值: \(outputBalance)")
                }
                
                // 检查是否为蓝牙设备，如果是则进行额外的音量同步
                if device.uid.lowercased().contains("bluetooth") {
                    print("检测到切换到蓝牙输出设备，进行额外的音量同步")
                    // 延迟执行以确保系统有时间更新设备状态
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                        self.syncBluetoothDeviceVolume(device: device, isInput: false)
                        
                        // 再次重置平衡值
                        if device.resetBalance() {
                            print("蓝牙设备同步后重置平衡")
                            self.outputBalance = 0.0
                        }
                    }
                    
                    // 最后一次确认平衡值
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                        if device.resetBalance() {
                            print("最终确认蓝牙设备平衡已重置")
                            self.outputBalance = 0.0
                        }
                    }
                }
            }
            
            // 设置新的音量监听器
            removeVolumeListeners()
            setupVolumeListeners()
            
            // 重新启动音量轮询
            startVolumePollingTimer()
        } else {
            print("设置默认\(forInput ? "输入" : "输出")设备失败: \(status)")
        }
    }
    
    // 新增：同步蓝牙设备音量（设置设备时使用）
    private func syncBluetoothDeviceVolume(device: AudioDevice, isInput: Bool) {
        let scope = isInput ? kAudioDevicePropertyScopeInput : kAudioDevicePropertyScopeOutput
        
        // 尝试使用硬件服务属性获取音量值
        var hardwareServiceAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var volume: Float32 = 0.0
        var size = UInt32(MemoryLayout<Float32>.size)
        
        if AudioObjectHasProperty(device.id, &hardwareServiceAddress) {
            let status = AudioObjectGetPropertyData(device.id, &hardwareServiceAddress, 0, nil, &size, &volume)
            if status == noErr {
                print("使用硬件服务属性获取蓝牙设备 \(device.name) 音量: \(volume)")
                
                // 检查音量是否需要更新
                let currentVolume = isInput ? self.inputVolume : self.outputVolume
                if abs(volume - currentVolume) > 0.001 {
                    DispatchQueue.main.async {
                        if isInput {
                            self.inputVolume = volume
                            self.lastBluetoothInputVolume = volume
                        } else {
                            self.outputVolume = volume
                            self.lastBluetoothOutputVolume = volume
                        }
                        print("已更新蓝牙设备音量: \(volume)")
                    }
                }
                
                return
            }
        }
        
        // 如果硬件服务属性失败，尝试其他属性
        let volumeProperties: [AudioObjectPropertySelector] = [
            kAudioDevicePropertyVirtualMasterVolume,
            kAudioDevicePropertyVolumeScalar
        ]
        
        for property in volumeProperties {
            var address = AudioObjectPropertyAddress(
                mSelector: property,
                mScope: scope,
                mElement: kAudioObjectPropertyElementMain
            )
            
            if AudioObjectHasProperty(device.id, &address) {
                let status = AudioObjectGetPropertyData(device.id, &address, 0, nil, &size, &volume)
                if status == noErr {
                    print("使用属性 \(property) 获取蓝牙设备 \(device.name) 音量: \(volume)")
                    
                    // 检查音量是否需要更新
                    let currentVolume = isInput ? self.inputVolume : self.outputVolume
                    if abs(volume - currentVolume) > 0.001 {
                        DispatchQueue.main.async {
                            if isInput {
                                self.inputVolume = volume
                                self.lastBluetoothInputVolume = volume
                            } else {
                                self.outputVolume = volume
                                self.lastBluetoothOutputVolume = volume
                            }
                            print("已更新蓝牙设备音量: \(volume)")
                        }
                    }
                    
                    return
                }
            }
        }
        
        print("无法获取蓝牙设备 \(device.name) 的准确音量")
    }
    
    // 使用硬件API直接设置音量
    private func directlySetDeviceVolume(_ device: AudioDevice, _ volume: Float) -> Bool {
        print("直接设置设备[\(device.name)]音量: \(volume)")
        
        let deviceID = device.id
        let scope = device.isOutput ? kAudioDevicePropertyScopeOutput : kAudioDevicePropertyScopeInput
        var volumeValue = volume
        
        // 尝试通过硬件服务属性设置
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        if AudioObjectHasProperty(deviceID, &address) {
            var canSetVolume = UInt32(0)
            var propertySize = UInt32(MemoryLayout<UInt32>.size)
            
            let canSetVolumeResult = AudioObjectGetPropertyData(
                deviceID,
                &address,
                0,
                nil,
                &propertySize,
                &canSetVolume
            )
            
            if canSetVolumeResult == noErr && canSetVolume != 0 {
                propertySize = UInt32(MemoryLayout<Float>.size)
                
                let setVolumeResult = AudioHardwareServiceSetPropertyData(
                    deviceID,
                    &address,
                    0,
                    nil,
                    propertySize,
                    &volumeValue
                )
                
                if setVolumeResult == noErr {
                    print("通过硬件服务属性成功设置设备[\(device.name)]音量: \(volume)")
                    return true
                } else {
                    print("通过硬件服务属性设置音量失败: \(setVolumeResult)")
                }
            }
        }
        
        // 如果硬件服务失败，尝试通过标准属性设置
        address.mSelector = kAudioDevicePropertyVolumeScalar
        
        if AudioObjectHasProperty(deviceID, &address) {
            var canSetVolume = UInt32(0)
            var propertySize = UInt32(MemoryLayout<UInt32>.size)
            
            let canSetVolumeResult = AudioObjectGetPropertyData(
                deviceID,
                &address,
                0,
                nil,
                &propertySize,
                &canSetVolume
            )
            
            if canSetVolumeResult == noErr && canSetVolume != 0 {
                propertySize = UInt32(MemoryLayout<Float>.size)
                
                let setVolumeResult = AudioObjectSetPropertyData(
                    deviceID,
                    &address,
                    0,
                    nil,
                    propertySize,
                    &volumeValue
                )
                
                if setVolumeResult == noErr {
                    print("通过标准属性成功设置设备[\(device.name)]音量: \(volume)")
                    return true
                } else {
                    print("通过标准属性设置音量失败: \(setVolumeResult)")
                }
            }
        }
        
        print("所有直接方法都无法设置设备[\(device.name)]音量")
        return false
    }
    
    // 同步音量到系统
    private func syncVolumeToSystem(_ device: AudioDevice, _ volume: Float) {
        print("同步设备[\(device.name)]音量到系统: \(volume)")
        
        let deviceID = device.id
        let scope = device.isOutput ? kAudioDevicePropertyScopeOutput : kAudioDevicePropertyScopeInput
        
        // 这些是可能的音量通知属性
        let volumeNotifyProperties: [AudioObjectPropertySelector] = [
            kAudioDevicePropertyVolumeScalar,
            kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            kAudioDevicePropertyVirtualMasterVolume
        ]
        
        // 为每个属性创建临时监听器来触发变化通知
        for propertySelector in volumeNotifyProperties {
            var address = AudioObjectPropertyAddress(
                mSelector: propertySelector,
                mScope: scope,
                mElement: kAudioObjectPropertyElementMain
            )
            
            if AudioObjectHasProperty(deviceID, &address) {
                var volumeValue = volume
                var propertySize = UInt32(MemoryLayout<Float>.size)
                
                // 尝试设置音量
                let setResult = AudioHardwareServiceSetPropertyData(
                    deviceID,
                    &address,
                    0,
                    nil,
                    propertySize,
                    &volumeValue
                )
                
                if setResult == noErr {
                    print("通过属性[\(propertySelector)]成功同步设备[\(device.name)]音量: \(volume)")
                }
            }
        }
        
        // 特殊处理蓝牙设备
        if device.uid.lowercased().contains("bluetooth") {
            // 蓝牙设备可能需要更多尝试
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                var address = AudioObjectPropertyAddress(
                    mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
                    mScope: scope,
                    mElement: kAudioObjectPropertyElementMain
                )
                
                if AudioObjectHasProperty(deviceID, &address) {
                    var volumeValue = volume
                    var propertySize = UInt32(MemoryLayout<Float>.size)
                    
                    let _ = AudioHardwareServiceSetPropertyData(
                        deviceID,
                        &address,
                        0,
                        nil,
                        propertySize,
                        &volumeValue
                    )
                }
            }
        }
    }
    
    func setVolumeForDevice(_ device: AudioDevice, _ volume: Float) {
        print("设置设备[\(device.name)]音量: \(volume)")
        let isBluetoothDevice = device.uid.lowercased().contains("bluetooth")
        
        // 保存当前状态
        let originalVolume = device.getVolume()
        let originalBalance = device.getBalance()
        
        if isBluetoothDevice {
            print("检测到蓝牙设备[\(device.name)]，使用特殊音量设置流程")
            print("当前平衡值: \(originalBalance)")
            
            // 蓝牙设备特殊处理
            if setVolumeForBluetoothDevice(device, volume, originalBalance) {
                print("蓝牙设备音量设置成功: \(volume)")
                
                // 更新内存中的音量值
                if device.isOutput {
                    if selectedOutputDevice?.id == device.id {
                        outputVolume = volume
                    }
                } else {
                    if selectedInputDevice?.id == device.id {
                        inputVolume = volume
                    }
                }
                
                // 防止平衡值被改变
                protectDeviceBalance(device, originalBalance)
                
                return
            } else {
                print("蓝牙设备特殊音量设置失败，尝试标准方法")
            }
        }
        
        // 标准音量设置流程
        if directlySetDeviceVolume(device, volume) {
            // 更新内存中的音量值
            if device.isOutput {
                if selectedOutputDevice?.id == device.id {
                    outputVolume = volume
                }
            } else {
                if selectedInputDevice?.id == device.id {
                    inputVolume = volume
                }
            }
            
            // 检查平衡值是否被改变
            let newBalance = device.getBalance()
            if abs(newBalance - originalBalance) > 0.01 {
                print("检测到平衡值变化: \(originalBalance) -> \(newBalance)，尝试恢复")
                if device.setBalance(originalBalance) {
                    print("成功恢复平衡值到: \(originalBalance)")
                } else {
                    print("无法恢复平衡值")
                }
            }
        } else {
            print("直接设置音量失败，使用设备原生方法")
            
            // 使用设备的原生方法
            if device.setVolume(volume) {
                // 更新内存中的音量值
                if device.isOutput {
                    if selectedOutputDevice?.id == device.id {
                        outputVolume = volume
                    }
                } else {
                    if selectedInputDevice?.id == device.id {
                        inputVolume = volume
                    }
                }
                
                // 检查平衡值是否被改变
                let newBalance = device.getBalance()
                if abs(newBalance - originalBalance) > 0.01 {
                    print("检测到平衡值变化: \(originalBalance) -> \(newBalance)，尝试恢复")
                    if device.setBalance(originalBalance) {
                        print("成功恢复平衡值到: \(originalBalance)")
                    } else {
                        print("无法恢复平衡值")
                    }
                }
            } else {
                print("设置音量失败")
            }
        }
    }
    
    // 为蓝牙设备设置音量的特殊方法
    private func setVolumeForBluetoothDevice(_ device: AudioDevice, _ volume: Float, _ originalBalance: Float) -> Bool {
        let deviceID = device.id
        var success = false
        
        // 1. 首先尝试通过虚拟主音量设置
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            mScope: device.isOutput ? kAudioDevicePropertyScopeOutput : kAudioDevicePropertyScopeInput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var canSetVolume = UInt32(0)
        var propertySize = UInt32(MemoryLayout<UInt32>.size)
        
        let canSetVolumeResult = AudioObjectGetPropertyData(
            deviceID,
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &canSetVolume
        )
        
        if canSetVolumeResult == noErr && canSetVolume != 0 {
            var volumeValue = volume
            propertySize = UInt32(MemoryLayout<Float>.size)
            
            let setVolumeResult = AudioHardwareServiceSetPropertyData(
                deviceID,
                &propertyAddress,
                0,
                nil,
                propertySize,
                &volumeValue
            )
            
            if setVolumeResult == noErr {
                print("通过虚拟主音量设置蓝牙设备音量成功: \(volume)")
                success = true
            } else {
                print("通过虚拟主音量设置音量失败: \(setVolumeResult)")
            }
        }
        
        // 2. 如果第一种方法失败，尝试通过普通音量属性设置
        if !success {
            propertyAddress.mSelector = kAudioDevicePropertyVolumeScalar
            
            canSetVolume = UInt32(0)
            propertySize = UInt32(MemoryLayout<UInt32>.size)
            
            let canSetVolumeResult = AudioObjectGetPropertyData(
                deviceID,
                &propertyAddress,
                0,
                nil,
                &propertySize,
                &canSetVolume
            )
            
            if canSetVolumeResult == noErr && canSetVolume != 0 {
                var volumeValue = volume
                propertySize = UInt32(MemoryLayout<Float>.size)
                
                let setVolumeResult = AudioObjectSetPropertyData(
                    deviceID,
                    &propertyAddress,
                    0,
                    nil,
                    propertySize,
                    &volumeValue
                )
                
                if setVolumeResult == noErr {
                    print("通过普通音量属性设置蓝牙设备音量成功: \(volume)")
                    success = true
                } else {
                    print("通过普通音量属性设置音量失败: \(setVolumeResult)")
                }
            }
        }
        
        // 3. 如果所有方法都失败，尝试单独设置左右声道
        if !success {
            var leftSuccess = false
            var rightSuccess = false
            
            // 设置左声道
            var leftAddress = AudioObjectPropertyAddress(
                mSelector: kAudioDevicePropertyVolumeScalar,
                mScope: device.isOutput ? kAudioDevicePropertyScopeOutput : kAudioDevicePropertyScopeInput,
                mElement: 1
            )
            
            var volumeValue = volume
            var propertySize = UInt32(MemoryLayout<Float>.size)
            
            let leftResult = AudioObjectSetPropertyData(
                deviceID,
                &leftAddress,
                0,
                nil,
                propertySize,
                &volumeValue
            )
            
            if leftResult == noErr {
                leftSuccess = true
                print("设置左声道音量成功: \(volume)")
            }
            
            // 设置右声道
            var rightAddress = AudioObjectPropertyAddress(
                mSelector: kAudioDevicePropertyVolumeScalar,
                mScope: device.isOutput ? kAudioDevicePropertyScopeOutput : kAudioDevicePropertyScopeInput,
                mElement: 2
            )
            
            let rightResult = AudioObjectSetPropertyData(
                deviceID,
                &rightAddress,
                0,
                nil,
                propertySize,
                &volumeValue
            )
            
            if rightResult == noErr {
                rightSuccess = true
                print("设置右声道音量成功: \(volume)")
            }
            
            success = leftSuccess && rightSuccess
        }
        
        // 同步到系统UI
        if success {
            syncVolumeToSystem(device, volume)
        }
        
        return success
    }
    
    // 保护设备平衡值
    private func protectDeviceBalance(_ device: AudioDevice, _ originalBalance: Float) {
        // 立即检查平衡值
        let immediateBalance = device.getBalance()
        if abs(immediateBalance - originalBalance) > 0.01 {
            print("立即检测到平衡值变化: \(originalBalance) -> \(immediateBalance)，尝试恢复")
            if device.setBalance(originalBalance) {
                print("成功恢复平衡值到: \(originalBalance)")
            } else {
                print("无法恢复平衡值")
            }
        }
        
        // 延迟检查平衡值，以防止系统延迟更新
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
            let delayedBalance = device.getBalance()
            if abs(delayedBalance - originalBalance) > 0.01 {
                print("延时检测到平衡值变化: \(originalBalance) -> \(delayedBalance)，尝试恢复")
                if device.setBalance(originalBalance) {
                    print("成功恢复平衡值到: \(originalBalance)")
                } else {
                    print("无法恢复平衡值")
                }
            }
        }
        
        // 再次延迟检查，以应对系统更慢的更新
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
            let finalBalance = device.getBalance()
            if abs(finalBalance - originalBalance) > 0.01 {
                print("最终检测到平衡值变化: \(originalBalance) -> \(finalBalance)，尝试恢复")
                if device.setBalance(originalBalance) {
                    print("成功恢复平衡值到: \(originalBalance)")
                } else {
                    print("无法恢复平衡值，尝试重置平衡")
                    if abs(finalBalance) > 0.05 && device.resetBalance() {
                        print("已重置设备平衡值到中心位置")
                    }
                }
            }
        }
    }
    
    // 新增：设置设备平衡
    func setBalanceForDevice(device: AudioDevice, balance: Float, isInput: Bool) {
        print("正在设置设备 \(device.name) 的平衡为 \(balance)")
        
        if device.setBalance(balance) {
            print("平衡设置成功")
            // 更新状态
            if isInput {
                self.inputBalance = balance
            } else {
                self.outputBalance = balance
            }
        } else {
            print("平衡设置失败")
        }
    }
    
    // 新增：重置设备平衡到中心位置
    func resetBalanceForDevice(device: AudioDevice, isInput: Bool) {
        print("正在重置设备 \(device.name) 的平衡到中心位置")
        
        if device.resetBalance() {
            print("平衡重置成功")
            // 更新状态
            if isInput {
                self.inputBalance = 0.0
            } else {
                self.outputBalance = 0.0
            }
        } else {
            print("平衡重置失败")
        }
    }
    
    private func updateDeviceVolumes() {
        print("更新设备音量状态")
        if let outputDevice = selectedOutputDevice {
            print("获取输出设备 \(outputDevice.name) 的音量")
            let newVolume = outputDevice.getVolume()
            
            // 首先尝试重置平衡到中心位置
            if outputDevice.resetBalance() {
                outputBalance = 0.0
                print("已重置输出设备 \(outputDevice.name) 平衡到中心位置")
            } else {
                outputBalance = outputDevice.getBalance()
            }
            
            // 检查当前音量是否与存储的音量不同
            if abs(newVolume - outputVolume) > 0.001 {
                print("输出设备音量已更新: \(outputVolume) -> \(newVolume)")
                outputVolume = newVolume
                
                // 更新蓝牙设备基准音量
                if outputDevice.uid.lowercased().contains("bluetooth") {
                    lastBluetoothOutputVolume = newVolume
                }
            }
            
            print("当前输出音量: \(outputVolume), 平衡: \(outputBalance)")
        }
        
        if let inputDevice = selectedInputDevice {
            print("获取输入设备 \(inputDevice.name) 的音量")
            let newVolume = inputDevice.getVolume()
            
            // 首先尝试重置平衡到中心位置
            if inputDevice.resetBalance() {
                inputBalance = 0.0
                print("已重置输入设备 \(inputDevice.name) 平衡到中心位置")
            } else {
                inputBalance = inputDevice.getBalance()
            }
            
            // 检查当前音量是否与存储的音量不同
            if abs(newVolume - inputVolume) > 0.001 {
                print("输入设备音量已更新: \(inputVolume) -> \(newVolume)")
                inputVolume = newVolume
                
                // 更新蓝牙设备基准音量
                if inputDevice.uid.lowercased().contains("bluetooth") {
                    lastBluetoothInputVolume = newVolume
                }
            }
            
            print("当前输入音量: \(inputVolume), 平衡: \(inputBalance)")
        }
    }
    
    private func startDeviceMonitoring() {
        // 监听设备变化
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        let callback: AudioObjectPropertyListenerProc = { _, _, _, _ in
            DispatchQueue.main.async {
                AudioManager.shared.updateDevices()
            }
            return noErr
        }
        
        let status = AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &address,
            callback,
            nil
        )
        
        if status != noErr {
            print("添加设备监听失败: \(status)")
        }
        
        // 监听默认设备变化
        var outputAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var inputAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &outputAddress,
            callback,
            nil
        )
        
        AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &inputAddress,
            callback,
            nil
        )
    }
    
    private func setupListeners() {
        let selfPtr = Unmanaged.passUnretained(self).toOpaque()
        
        // 设备列表变化监听
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        deviceListenerID = { _, _, _, context in
            let manager = Unmanaged<AudioManager>.fromOpaque(context!).takeUnretainedValue()
            DispatchQueue.main.async {
                manager.updateDevices()
            }
            return noErr
        }
        
        if let listener = deviceListenerID {
            AudioObjectAddPropertyListener(
                AudioObjectID(kAudioObjectSystemObject),
                &propertyAddress,
                listener,
                selfPtr
            )
        }
        
        // 设置默认设备变化监听器
        setupDefaultDeviceListeners()
        // 设置音量变化监听器
        setupVolumeListeners()
    }
    
    private func setupDefaultDeviceListeners() {
        let selfPtr = Unmanaged.passUnretained(self).toOpaque()
        
        // 设备列表变化监听
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            { _, _, _, context in
                let manager = Unmanaged<AudioManager>.fromOpaque(context!).takeUnretainedValue()
                DispatchQueue.main.async {
                    manager.updateDevices()
                }
                return noErr
            },
            selfPtr
        )
        
        // 默认输入设备变化监听
        var inputPropertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &inputPropertyAddress,
            { _, _, _, context in
                let manager = Unmanaged<AudioManager>.fromOpaque(context!).takeUnretainedValue()
                DispatchQueue.main.async {
                    manager.updateSelectedDevices()
                }
                return noErr
            },
            selfPtr
        )
        
        // 默认输出设备变化监听
        var outputPropertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        AudioObjectAddPropertyListener(
            AudioObjectID(kAudioObjectSystemObject),
            &outputPropertyAddress,
            { _, _, _, context in
                let manager = Unmanaged<AudioManager>.fromOpaque(context!).takeUnretainedValue()
                DispatchQueue.main.async {
                    manager.updateSelectedDevices()
                }
                return noErr
            },
            selfPtr
        )
    }
    
    private func setupVolumeListeners() {
        // 移除旧的监听器
        removeVolumeListeners()
        
        // 设置输入设备的音量监听器
        if let device = selectedInputDevice {
            let deviceID = device.id
            let scope = kAudioDevicePropertyScopeInput
            let isBluetoothDevice = device.uid.lowercased().contains("bluetooth")
            
            print("为\(isBluetoothDevice ? "蓝牙" : "")输入设备 \(device.name) 设置音量监听器")
            
            // 创建要监听的属性地址列表
            var addresses: [AudioObjectPropertyAddress] = []
            
            // 添加所有可能的音量控制属性
            let volumeSelectors: [AudioObjectPropertySelector] = [
                kAudioDevicePropertyVolumeScalar,
                kAudioDevicePropertyVirtualMasterVolume,
                kAudioHardwareServiceDeviceProperty_VirtualMasterVolume
            ]
            
            // 对于蓝牙设备，优先使用硬件服务属性
            if isBluetoothDevice {
                var hardwareServiceAddress = AudioObjectPropertyAddress(
                    mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
                    mScope: scope,
                    mElement: kAudioObjectPropertyElementMain
                )
                
                if AudioObjectHasProperty(deviceID, &hardwareServiceAddress) {
                    addresses.append(hardwareServiceAddress)
                    print("添加蓝牙设备硬件服务属性音量监听器")
                }
            }
            
            // 添加剩余的音量属性
            for selector in volumeSelectors {
                // 跳过已添加的硬件服务属性
                if isBluetoothDevice && selector == kAudioHardwareServiceDeviceProperty_VirtualMasterVolume {
                    continue
                }
                
                // 监听主元素
                var address = AudioObjectPropertyAddress(
                    mSelector: selector,
                    mScope: scope,
                    mElement: kAudioObjectPropertyElementMain
                )
                
                if AudioObjectHasProperty(deviceID, &address) {
                    addresses.append(address)
                }
                
                // 监听第一个通道
                address.mElement = 1
                if AudioObjectHasProperty(deviceID, &address) {
                    addresses.append(address)
                }
            }
            
            let selfPtr = Unmanaged.passUnretained(self).toOpaque()
            
            // 保存回调函数引用
            let inputCallback: AudioObjectPropertyListenerProc = inputVolumeChanged
            inputVolumeListenerID = inputCallback
            
            // 为每个地址设置监听器
            for var address in addresses {
                let status = AudioObjectAddPropertyListener(
                    deviceID,
                    &address,
                    inputCallback,
                    selfPtr
                )
                
                if status == noErr {
                    print("成功为输入设备 \(device.name) 设置音量监听器 (属性: \(address.mSelector), 元素: \(address.mElement))")
                } else {
                    print("为输入设备 \(device.name) 设置音量监听器失败 (属性: \(address.mSelector), 元素: \(address.mElement)), 状态码: \(status)")
                }
            }
        }
        
        // 设置输出设备的音量监听器
        if let device = selectedOutputDevice {
            let deviceID = device.id
            let scope = kAudioDevicePropertyScopeOutput
            let isBluetoothDevice = device.uid.lowercased().contains("bluetooth")
            
            print("为\(isBluetoothDevice ? "蓝牙" : "")输出设备 \(device.name) 设置音量监听器")
            
            // 创建要监听的属性地址列表
            var addresses: [AudioObjectPropertyAddress] = []
            
            // 添加所有可能的音量控制属性
            let volumeSelectors: [AudioObjectPropertySelector] = [
                kAudioDevicePropertyVolumeScalar,
                kAudioDevicePropertyVirtualMasterVolume,
                kAudioHardwareServiceDeviceProperty_VirtualMasterVolume
            ]
            
            // 对于蓝牙设备，优先使用硬件服务属性
            if isBluetoothDevice {
                var hardwareServiceAddress = AudioObjectPropertyAddress(
                    mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
                    mScope: scope,
                    mElement: kAudioObjectPropertyElementMain
                )
                
                if AudioObjectHasProperty(deviceID, &hardwareServiceAddress) {
                    addresses.append(hardwareServiceAddress)
                    print("添加蓝牙设备硬件服务属性音量监听器")
                }
            }
            
            // 添加主元素和通道监听
            let elements: [UInt32] = [kAudioObjectPropertyElementMain, 0, 1, 2]
            
            // 添加剩余的音量属性
            for selector in volumeSelectors {
                // 跳过已添加的硬件服务属性
                if isBluetoothDevice && selector == kAudioHardwareServiceDeviceProperty_VirtualMasterVolume {
                    continue
                }
                
                for element in elements {
                    var address = AudioObjectPropertyAddress(
                        mSelector: selector,
                        mScope: scope,
                        mElement: element
                    )
                    
                    if AudioObjectHasProperty(deviceID, &address) {
                        addresses.append(address)
                    }
                }
            }
            
            let selfPtr = Unmanaged.passUnretained(self).toOpaque()
            
            // 保存回调函数引用
            let outputCallback: AudioObjectPropertyListenerProc = outputVolumeChanged
            outputVolumeListenerID = outputCallback
            
            // 为每个地址设置监听器
            for var address in addresses {
                let status = AudioObjectAddPropertyListener(
                    deviceID,
                    &address,
                    outputCallback,
                    selfPtr
                )
                
                if status == noErr {
                    print("成功为输出设备 \(device.name) 设置音量监听器 (属性: \(address.mSelector), 元素: \(address.mElement))")
                } else {
                    print("为输出设备 \(device.name) 设置音量监听器失败 (属性: \(address.mSelector), 元素: \(address.mElement)), 状态码: \(status)")
                }
            }
            
            // 对于蓝牙设备，确保首次同步
            if isBluetoothDevice {
                // 延迟执行音量获取，确保监听器已设置好
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    let volume = self.getSystemVolumeForDevice(device: device, isInput: false)
                    if abs(volume - self.outputVolume) > 0.01 {
                        print("监听器设置后更新蓝牙设备音量: \(volume)")
                        DispatchQueue.main.async {
                            self.outputVolume = volume
                            self.lastBluetoothOutputVolume = volume
                        }
                    }
                }
            }
        }
    }
    
    // 添加系统音量监听器 - 针对所有设备类型
    private func setupSystemAudioVolumeListener() {
        print("设置系统音量监听器")
        
        // 使用NotificationCenter监听系统音量变化
        NotificationCenter.default.removeObserver(self, name: NSNotification.Name(rawValue: "AVSystemController_SystemVolumeDidChangeNotification"), object: nil)
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(handleSystemVolumeChange),
            name: NSNotification.Name(rawValue: "AVSystemController_SystemVolumeDidChangeNotification"),
            object: nil
        )
        
        // 在macOS中不需要额外的音频会话设置，移除AVAudioSession相关代码
        print("已设置系统音量变化通知监听器")
    }
    
    @objc private func handleSystemVolumeChange(notification: Notification) {
        print("收到系统音量变化通知")
        
        // 使用较短的延迟立即响应音量变化
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
            // 对于蓝牙设备，使用专用的同步方法
            if let device = self.selectedOutputDevice, device.uid.lowercased().contains("bluetooth") {
                let systemVolume = self.directSystemVolumeQuery(device: device, isInput: false)
                print("系统音量变化: 蓝牙输出设备音量 -> \(systemVolume)")
                
                DispatchQueue.main.async {
                    self.outputVolume = systemVolume
                    self.lastBluetoothOutputVolume = systemVolume
                }
                
                // 检查并维护平衡值
                self.maintainBalanceCenter(device: device, isInput: false)
            } else {
                // 非蓝牙设备使用常规方法更新
                self.forceUpdateDeviceVolumes()
            }
        }
    }
    
    // 启动音量轮询定时器 - 对所有设备类型生效
    private func startVolumePollingTimer() {
        print("启动音量轮询定时器")
        
        // 停止可能正在运行的定时器
        volumePollingTimer?.invalidate()
        volumePollingTimer = nil
        
        // 记录初始音量值
        if let outputDevice = selectedOutputDevice {
            lastBluetoothOutputVolume = outputDevice.getVolume()
            print("初始输出设备音量: \(lastBluetoothOutputVolume)")
        }
        
        if let inputDevice = selectedInputDevice {
            lastBluetoothInputVolume = inputDevice.getVolume()
            print("初始输入设备音量: \(lastBluetoothInputVolume)")
        }
        
        // 创建新的轮询定时器，每0.5秒检查一次
        volumePollingTimer = Timer.scheduledTimer(withTimeInterval: 0.5, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.checkDeviceVolumeChanges()
        }
        
        isPollingForVolumeChanges = true
    }
    
    // 停止音量轮询
    private func stopVolumePollingTimer() {
        print("停止音量轮询定时器")
        volumePollingTimer?.invalidate()
        volumePollingTimer = nil
        isPollingForVolumeChanges = false
    }
    
    // 检查所有设备音量变化
    private func checkDeviceVolumeChanges() {
        // 检查输出设备
        if let outputDevice = selectedOutputDevice {
            let currentVolume = outputDevice.getVolume()
            
            // 如果音量有显著变化 (避免更新循环)
            if abs(currentVolume - lastBluetoothOutputVolume) > 0.001 && abs(currentVolume - outputVolume) > 0.001 {
                print("检测到输出设备 \(outputDevice.name) 音量变化: \(lastBluetoothOutputVolume) -> \(currentVolume)")
                DispatchQueue.main.async {
                    self.outputVolume = currentVolume
                }
                lastBluetoothOutputVolume = currentVolume
            }
        }
        
        // 检查输入设备
        if let inputDevice = selectedInputDevice {
            let currentVolume = inputDevice.getVolume()
            
            // 如果音量有显著变化
            if abs(currentVolume - lastBluetoothInputVolume) > 0.001 && abs(currentVolume - inputVolume) > 0.001 {
                print("检测到输入设备 \(inputDevice.name) 音量变化: \(lastBluetoothInputVolume) -> \(currentVolume)")
                DispatchQueue.main.async {
                    self.inputVolume = currentVolume
                }
                lastBluetoothInputVolume = currentVolume
            }
        }
    }
    
    // 强制同步所有设备音量 - 最终同步尝试
    private func forceSyncAllDevicesVolume() {
        print("执行最终音量同步尝试")
        
        // 对于蓝牙设备，使用专用的同步方法
        let isBluetoothOutput = selectedOutputDevice?.uid.lowercased().contains("bluetooth") ?? false
        let isBluetoothInput = selectedInputDevice?.uid.lowercased().contains("bluetooth") ?? false
        
        // 对蓝牙设备使用直接查询方法
        if isBluetoothOutput || isBluetoothInput {
            forceBluetoothVolumeSync(highPriority: true)
        }
        
        // 对于非蓝牙设备，使用常规更新方法
        if !isBluetoothOutput && selectedOutputDevice != nil {
            print("最终同步: 更新普通输出设备音量")
            if let device = selectedOutputDevice {
                let volume = directSystemVolumeQuery(device: device, isInput: false)
                DispatchQueue.main.async {
                    self.outputVolume = volume
                }
            }
        }
        
        if !isBluetoothInput && selectedInputDevice != nil {
            print("最终同步: 更新普通输入设备音量")
            if let device = selectedInputDevice {
                let volume = directSystemVolumeQuery(device: device, isInput: true)
                DispatchQueue.main.async {
                    self.inputVolume = volume
                }
            }
        }
        
        // 记录音量值以便后续对比
        print("最终同步完成 - 输出音量: \(outputVolume), 输入音量: \(inputVolume)")
    }
    
    // 强制更新设备音量 - 确保会更新TUNA中的音量值
    private func forceUpdateDeviceVolumes() {
        print("强制更新设备音量状态")
        
        if let outputDevice = selectedOutputDevice {
            print("获取输出设备 \(outputDevice.name) 的当前音量")
            
            // 使用直接查询获取更准确的音量值
            let newVolume = directSystemVolumeQuery(device: outputDevice, isInput: false)
            
            // 无条件更新音量值
            print("输出设备音量已更新: \(outputVolume) -> \(newVolume)")
            lastBluetoothOutputVolume = newVolume
            
            DispatchQueue.main.async {
                self.outputVolume = newVolume
                
                // 重置平衡到中心位置
                if outputDevice.resetBalance() {
                    self.outputBalance = 0.0
                    print("已重置输出设备 \(outputDevice.name) 平衡到中心位置")
                } else {
                    self.outputBalance = outputDevice.getBalance()
                }
                
                print("当前输出音量: \(self.outputVolume), 平衡: \(self.outputBalance)")
            }
            
            // 特别处理蓝牙设备的平衡问题
            if outputDevice.uid.lowercased().contains("bluetooth") {
                // 延迟一点时间再次确保平衡值重置
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    self.maintainBalanceCenter(device: outputDevice, isInput: false)
                }
            }
        }
        
        if let inputDevice = selectedInputDevice {
            print("获取输入设备 \(inputDevice.name) 的当前音量")
            
            // 使用直接查询获取更准确的音量值
            let newVolume = directSystemVolumeQuery(device: inputDevice, isInput: true)
            
            // 无条件更新音量值
            print("输入设备音量已更新: \(inputVolume) -> \(newVolume)")
            lastBluetoothInputVolume = newVolume
            
            DispatchQueue.main.async {
                self.inputVolume = newVolume
                
                // 重置平衡到中心位置
                if inputDevice.resetBalance() {
                    self.inputBalance = 0.0
                    print("已重置输入设备 \(inputDevice.name) 平衡到中心位置")
                } else {
                    self.inputBalance = inputDevice.getBalance()
                }
                
                print("当前输入音量: \(self.inputVolume), 平衡: \(self.inputBalance)")
            }
            
            // 特别处理蓝牙设备的平衡问题
            if inputDevice.uid.lowercased().contains("bluetooth") {
                // 延迟一点时间再次确保平衡值重置
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    self.maintainBalanceCenter(device: inputDevice, isInput: true)
                }
            }
        }
    }
    
    private func updateSelectedDevices() {
        // 在更新设备之前移除旧的音量监听器
        removeVolumeListeners()
        
        // 获取默认输入设备
        var propertySize = UInt32(MemoryLayout<AudioDeviceID>.size)
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var inputDeviceID: AudioDeviceID = 0
        let status = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &inputDeviceID
        )
        
        if status == noErr {
            DispatchQueue.main.async {
                self.selectedInputDevice = self.inputDevices.first { $0.id == inputDeviceID }
            }
        }
        
        // 获取默认输出设备
        propertyAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice
        var outputDeviceID: AudioDeviceID = 0
        let outputStatus = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &outputDeviceID
        )
        
        if outputStatus == noErr {
            DispatchQueue.main.async {
                self.selectedOutputDevice = self.outputDevices.first { $0.id == outputDeviceID }
            }
        }
        
        // 更新音量和平衡
        if let inputDevice = selectedInputDevice {
            // 首先获取设备音量
            let newVolume = getDeviceVolume(device: inputDevice, isInput: true)
            
            // 重置平衡到中心位置
            if inputDevice.resetBalance() {
                inputBalance = 0.0
                print("已重置输入设备 \(inputDevice.name) 平衡到中心位置")
            } else {
                inputBalance = inputDevice.getBalance()
            }
            
            // 更新存储的音量值
            inputVolume = newVolume
            
            print("更新设备 \(inputDevice.name) 的音量为: \(inputVolume), 平衡为: \(inputBalance)")
            
            // 如果是蓝牙设备，执行额外的同步
            if inputDevice.uid.lowercased().contains("bluetooth") {
                // 延迟执行以确保系统有时间更新设备状态
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    self.syncBluetoothDeviceVolume(device: inputDevice, isInput: true)
                }
            }
        }
        
        if let outputDevice = selectedOutputDevice {
            // 首先获取设备音量
            let newVolume = getDeviceVolume(device: outputDevice, isInput: false)
            
            // 重置平衡到中心位置
            if outputDevice.resetBalance() {
                outputBalance = 0.0
                print("已重置输出设备 \(outputDevice.name) 平衡到中心位置")
            } else {
                outputBalance = outputDevice.getBalance()
            }
            
            // 更新存储的音量值
            outputVolume = newVolume
            
            print("更新设备 \(outputDevice.name) 的音量为: \(outputVolume), 平衡为: \(outputBalance)")
            
            // 如果平衡值不为0，尝试重置平衡（针对蓝牙耳机）
            if abs(outputBalance) > 0.01 && outputDevice.uid.contains("bluetooth") {
                print("检测到蓝牙耳机平衡偏移，尝试重置平衡")
                _ = outputDevice.resetBalance()
                // 重新获取平衡值
                outputBalance = outputDevice.getBalance()
                print("重置后平衡值: \(outputBalance)")
            }
            
            // 如果是蓝牙设备，执行额外的同步
            if outputDevice.uid.lowercased().contains("bluetooth") {
                // 延迟执行以确保系统有时间更新设备状态
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    self.syncBluetoothDeviceVolume(device: outputDevice, isInput: false)
                }
            }
        }
        
        // 设置新的音量监听器
        setupVolumeListeners()
    }
    
    private func getDeviceVolume(device: AudioDevice, isInput: Bool) -> Float {
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyVolumeScalar,
            mScope: isInput ? kAudioDevicePropertyScopeInput : kAudioDevicePropertyScopeOutput,
            mElement: kAudioObjectPropertyElementMain
        )
        
        // 检查设备是否支持音量控制
        if !AudioObjectHasProperty(device.id, &propertyAddress) {
            print("设备 \(device.name) 不支持音量控制")
            return 1.0
        }
        
        var volume: Float = 0.0
        var propertySize = UInt32(MemoryLayout<Float>.size)
        
        let status = AudioObjectGetPropertyData(
            device.id,
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &volume
        )
        
        if status != noErr {
            print("获取设备 \(device.name) 音量失败: \(status)")
            return 1.0
        }
        
        return volume
    }
    
    deinit {
        // 移除所有监听器
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDevices,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        let selfPtr = Unmanaged.passUnretained(self).toOpaque()
        
        if let listenerID = deviceListenerID {
            AudioObjectRemovePropertyListener(
                AudioObjectID(kAudioObjectSystemObject),
                &propertyAddress,
                listenerID,
                selfPtr
            )
        }
        
        if let listenerID = defaultInputListenerID {
            propertyAddress.mSelector = kAudioHardwarePropertyDefaultInputDevice
            AudioObjectRemovePropertyListener(
                AudioObjectID(kAudioObjectSystemObject),
                &propertyAddress,
                listenerID,
                selfPtr
            )
        }
        
        if let listenerID = defaultOutputListenerID {
            propertyAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice
            AudioObjectRemovePropertyListener(
                AudioObjectID(kAudioObjectSystemObject),
                &propertyAddress,
                listenerID,
                selfPtr
            )
        }
        
        // 移除音量监听器
        removeVolumeListeners()
        
        // 停止所有定时器
        volumePollingTimer?.invalidate()
        balanceProtectionTimer?.invalidate()
    }
    
    func selectInputDevice(_ device: AudioDevice) {
        setDefaultDevice(device, forInput: true)
    }
    
    func selectOutputDevice(_ device: AudioDevice) {
        setDefaultDevice(device, forInput: false)
    }
    
    // 修改removeVolumeListeners方法，确保所有监听器都被正确移除
    private func removeVolumeListeners() {
        // 移除系统音量通知
        NotificationCenter.default.removeObserver(self, name: NSNotification.Name(rawValue: "AVSystemController_SystemVolumeDidChangeNotification"), object: nil)
        
        let selfPtr = Unmanaged.passUnretained(self).toOpaque()
        
        // 移除输入设备音量监听器
        if let device = selectedInputDevice, let listenerID = inputVolumeListenerID {
            let deviceID = device.id
            let scope = kAudioDevicePropertyScopeInput
            
            // 添加所有可能的音量控制属性
            let volumeSelectors: [AudioObjectPropertySelector] = [
                kAudioDevicePropertyVolumeScalar,
                kAudioDevicePropertyVirtualMasterVolume,
                kAudioHardwareServiceDeviceProperty_VirtualMasterVolume
            ]
            
            // 添加主元素和通道监听
            let elements: [UInt32] = [kAudioObjectPropertyElementMain, 0, 1, 2]
            
            for selector in volumeSelectors {
                for element in elements {
                    var address = AudioObjectPropertyAddress(
                        mSelector: selector,
                        mScope: scope,
                        mElement: element
                    )
                    
                    if AudioObjectHasProperty(deviceID, &address) {
                        AudioObjectRemovePropertyListener(
                            deviceID,
                            &address,
                            listenerID,
                            selfPtr
                        )
                        print("移除输入设备 \(device.name) 音量监听器 (属性: \(selector), 元素: \(element))")
                    }
                }
            }
            
            inputVolumeListenerID = nil
        }
        
        // 移除输出设备音量监听器
        if let device = selectedOutputDevice, let listenerID = outputVolumeListenerID {
            let deviceID = device.id
            let scope = kAudioDevicePropertyScopeOutput
            
            // 添加所有可能的音量控制属性
            let volumeSelectors: [AudioObjectPropertySelector] = [
                kAudioDevicePropertyVolumeScalar,
                kAudioDevicePropertyVirtualMasterVolume,
                kAudioHardwareServiceDeviceProperty_VirtualMasterVolume
            ]
            
            // 添加主元素和通道监听
            let elements: [UInt32] = [kAudioObjectPropertyElementMain, 0, 1, 2]
            
            for selector in volumeSelectors {
                for element in elements {
                    var address = AudioObjectPropertyAddress(
                        mSelector: selector,
                        mScope: scope,
                        mElement: element
                    )
                    
                    if AudioObjectHasProperty(deviceID, &address) {
                        AudioObjectRemovePropertyListener(
                            deviceID,
                            &address,
                            listenerID,
                            selfPtr
                        )
                        print("移除输出设备 \(device.name) 音量监听器 (属性: \(selector), 元素: \(element))")
                    }
                }
            }
            
            outputVolumeListenerID = nil
        }
    }
    
    // 新增：获取更准确的系统音量值
    private func getAccurateSystemVolumes() {
        print("尝试获取系统准确音量值")
        
        // 处理输出设备
        if let deviceID = getDefaultOutputDeviceID() {
            if let device = AudioDevice(deviceID: deviceID) {
                print("系统默认输出设备: \(device.name) (ID: \(deviceID))")
                // 尝试使用多种方法获取音量
                let volume = getSystemVolumeForDevice(device: device, isInput: false)
                outputVolume = volume
                lastBluetoothOutputVolume = volume
                print("获取到默认输出设备音量: \(volume)")
                
                // 设置设备引用
                selectedOutputDevice = device
            }
        }
        
        // 处理输入设备
        if let deviceID = getDefaultInputDeviceID() {
            if let device = AudioDevice(deviceID: deviceID) {
                print("系统默认输入设备: \(device.name) (ID: \(deviceID))")
                // 尝试使用多种方法获取音量
                let volume = getSystemVolumeForDevice(device: device, isInput: true)
                inputVolume = volume
                lastBluetoothInputVolume = volume
                print("获取到默认输入设备音量: \(volume)")
                
                // 设置设备引用
                selectedInputDevice = device
            }
        }
    }
    
    // 获取默认输出设备ID
    private func getDefaultOutputDeviceID() -> AudioDeviceID? {
        var propertySize = UInt32(MemoryLayout<AudioDeviceID>.size)
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultOutputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var deviceID: AudioDeviceID = 0
        let status = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &deviceID
        )
        
        if status == noErr && deviceID != 0 {
            return deviceID
        }
        return nil
    }
    
    // 获取默认输入设备ID
    private func getDefaultInputDeviceID() -> AudioDeviceID? {
        var propertySize = UInt32(MemoryLayout<AudioDeviceID>.size)
        var propertyAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwarePropertyDefaultInputDevice,
            mScope: kAudioObjectPropertyScopeGlobal,
            mElement: kAudioObjectPropertyElementMain
        )
        
        var deviceID: AudioDeviceID = 0
        let status = AudioObjectGetPropertyData(
            AudioObjectID(kAudioObjectSystemObject),
            &propertyAddress,
            0,
            nil,
            &propertySize,
            &deviceID
        )
        
        if status == noErr && deviceID != 0 {
            return deviceID
        }
        return nil
    }
    
    // 通过多种方法获取系统音量
    private func getSystemVolumeForDevice(device: AudioDevice, isInput: Bool) -> Float {
        let scope = isInput ? kAudioDevicePropertyScopeInput : kAudioDevicePropertyScopeOutput
        let deviceID = device.id
        var volume: Float32 = 0.0
        var size = UInt32(MemoryLayout<Float32>.size)
        
        // 尝试方法1: 使用硬件服务属性(这对蓝牙设备最可靠)
        var hardwareServiceAddress = AudioObjectPropertyAddress(
            mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        if AudioObjectHasProperty(deviceID, &hardwareServiceAddress) {
            let status = AudioObjectGetPropertyData(deviceID, &hardwareServiceAddress, 0, nil, &size, &volume)
            if status == noErr {
                print("使用硬件服务属性获取设备 \(device.name) 音量: \(volume)")
                return volume
            }
        }
        
        // 尝试方法2: 使用虚拟主音量
        var virtualAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyVirtualMasterVolume,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        if AudioObjectHasProperty(deviceID, &virtualAddress) {
            let status = AudioObjectGetPropertyData(deviceID, &virtualAddress, 0, nil, &size, &volume)
            if status == noErr {
                print("使用虚拟主音量属性获取设备 \(device.name) 音量: \(volume)")
                return volume
            }
        }
        
        // 尝试方法3: 使用标准音量缩放器
        var standardAddress = AudioObjectPropertyAddress(
            mSelector: kAudioDevicePropertyVolumeScalar,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        if AudioObjectHasProperty(deviceID, &standardAddress) {
            let status = AudioObjectGetPropertyData(deviceID, &standardAddress, 0, nil, &size, &volume)
            if status == noErr {
                print("使用标准音量属性获取设备 \(device.name) 音量: \(volume)")
                return volume
            }
        }
        
        // 方法4: 尝试获取第一个通道的音量
        standardAddress.mElement = 1
        if AudioObjectHasProperty(deviceID, &standardAddress) {
            let status = AudioObjectGetPropertyData(deviceID, &standardAddress, 0, nil, &size, &volume)
            if status == noErr {
                print("使用第一通道音量属性获取设备 \(device.name) 音量: \(volume)")
                return volume
            }
        }
        
        // 回退到设备自己的getVolume方法
        let deviceVolume = device.getVolume()
        print("回退到设备 \(device.name) 的getVolume获取音量: \(deviceVolume)")
        return deviceVolume
    }
    
    // 集中优化的蓝牙设备音量同步方法
    private func forceBluetoothVolumeSync(highPriority: Bool = false) {
        // 处理输出设备
        if let device = selectedOutputDevice, device.uid.lowercased().contains("bluetooth") {
            print("强制同步蓝牙输出设备音量" + (highPriority ? " (高优先级)" : ""))
            
            // 直接查询设备的当前系统音量 (绕过缓存)
            let systemVolume = directSystemVolumeQuery(device: device, isInput: false)
            
            // 高优先级时无条件更新，或音量差异超过阈值时更新
            let shouldUpdate = highPriority || abs(systemVolume - outputVolume) > 0.01
            
            if shouldUpdate {
                print("更新蓝牙输出设备音量: \(outputVolume) -> \(systemVolume)")
                DispatchQueue.main.async {
                    self.outputVolume = systemVolume
                    self.lastBluetoothOutputVolume = systemVolume
                }
            }
            
            // 重置平衡到中心位置
            if highPriority || abs(outputBalance) > 0.01 {
                if device.resetBalance() {
                    DispatchQueue.main.async {
                        self.outputBalance = 0.0
                        print("已重置蓝牙输出设备平衡到中心位置")
                    }
                }
            }
        }
        
        // 处理输入设备
        if let device = selectedInputDevice, device.uid.lowercased().contains("bluetooth") {
            print("强制同步蓝牙输入设备音量" + (highPriority ? " (高优先级)" : ""))
            
            // 直接查询设备的当前系统音量 (绕过缓存)
            let systemVolume = directSystemVolumeQuery(device: device, isInput: true)
            
            // 高优先级时无条件更新，或音量差异超过阈值时更新
            let shouldUpdate = highPriority || abs(systemVolume - inputVolume) > 0.01
            
            if shouldUpdate {
                print("更新蓝牙输入设备音量: \(inputVolume) -> \(systemVolume)")
                DispatchQueue.main.async {
                    self.inputVolume = systemVolume
                    self.lastBluetoothInputVolume = systemVolume
                }
            }
            
            // 重置平衡到中心位置
            if highPriority || abs(inputBalance) > 0.01 {
                if device.resetBalance() {
                    DispatchQueue.main.async {
                        self.inputBalance = 0.0
                        print("已重置蓝牙输入设备平衡到中心位置")
                    }
                }
            }
        }
    }
    
    // 新的初始系统音量同步方法 - 专注于准确获取初始音量
    private func initialSystemVolumeSync() {
        print("执行初始系统音量同步")
        
        // 获取默认输出设备ID并同步音量
        if let deviceID = getDefaultOutputDeviceID() {
            if let device = AudioDevice(deviceID: deviceID) {
                print("系统默认输出设备: \(device.name)")
                // 检查是否为蓝牙设备
                let isBluetoothDevice = device.uid.lowercased().contains("bluetooth")
                
                // 获取准确的系统音量
                let systemVolume = directSystemVolumeQuery(device: device, isInput: false)
                
                // 无条件更新初始音量 (特别是对蓝牙设备)
                if isBluetoothDevice {
                    print("蓝牙输出设备初始音量: \(systemVolume)")
                }
                
                DispatchQueue.main.async {
                    self.outputVolume = systemVolume
                    self.lastBluetoothOutputVolume = systemVolume
                    // 重置平衡到中心位置
                    if device.resetBalance() {
                        self.outputBalance = 0.0
                    }
                }
                
                // 确保设备引用正确设置
                if selectedOutputDevice == nil || selectedOutputDevice?.id != deviceID {
                    selectedOutputDevice = device
                }
            }
        }
        
        // 获取默认输入设备ID并同步音量
        if let deviceID = getDefaultInputDeviceID() {
            if let device = AudioDevice(deviceID: deviceID) {
                print("系统默认输入设备: \(device.name)")
                // 检查是否为蓝牙设备
                let isBluetoothDevice = device.uid.lowercased().contains("bluetooth")
                
                // 获取准确的系统音量
                let systemVolume = directSystemVolumeQuery(device: device, isInput: true)
                
                // 无条件更新初始音量 (特别是对蓝牙设备)
                if isBluetoothDevice {
                    print("蓝牙输入设备初始音量: \(systemVolume)")
                }
                
                DispatchQueue.main.async {
                    self.inputVolume = systemVolume
                    self.lastBluetoothInputVolume = systemVolume
                    // 重置平衡到中心位置
                    if device.resetBalance() {
                        self.inputBalance = 0.0
                    }
                }
                
                // 确保设备引用正确设置
                if selectedInputDevice == nil || selectedInputDevice?.id != deviceID {
                    selectedInputDevice = device
                }
            }
        }
    }
    
    // 直接系统音量查询 - 优先使用硬件服务API，专为初始化设计
    private func directSystemVolumeQuery(device: AudioDevice, isInput: Bool) -> Float {
        let deviceID = device.id
        let scope = isInput ? kAudioDevicePropertyScopeInput : kAudioDevicePropertyScopeOutput
        var volume: Float32 = 0.0
        var size = UInt32(MemoryLayout<Float32>.size)
        
        // 首先尝试最可靠的硬件服务属性 (特别适用于蓝牙设备)
        var address = AudioObjectPropertyAddress(
            mSelector: kAudioHardwareServiceDeviceProperty_VirtualMasterVolume,
            mScope: scope,
            mElement: kAudioObjectPropertyElementMain
        )
        
        if AudioObjectHasProperty(deviceID, &address) {
            let status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &volume)
            if status == noErr {
                print("使用硬件服务属性获取初始音量: \(volume)")
                return volume
            }
        }
        
        // 尝试备用属性
        address.mSelector = kAudioDevicePropertyVirtualMasterVolume
        if AudioObjectHasProperty(deviceID, &address) {
            let status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &volume)
            if status == noErr {
                print("使用虚拟主音量属性获取初始音量: \(volume)")
                return volume
            }
        }
        
        // 最后尝试标准音量属性
        address.mSelector = kAudioDevicePropertyVolumeScalar
        if AudioObjectHasProperty(deviceID, &address) {
            let status = AudioObjectGetPropertyData(deviceID, &address, 0, nil, &size, &volume)
            if status == noErr {
                print("使用标准音量属性获取初始音量: \(volume)")
                return volume
            }
        }
        
        // 如果以上方法都失败，回退到设备的getVolume方法
        let deviceVolume = device.getVolume()
        print("使用设备getVolume获取初始音量: \(deviceVolume)")
        return deviceVolume
    }
    
    // 新增：维护平衡值在中心位置
    private func maintainBalanceCenter(device: AudioDevice, isInput: Bool) {
        print("检查并维护\(isInput ? "输入" : "输出")设备 \(device.name) 的平衡值")
        
        // 获取当前平衡值
        let currentBalance = device.getBalance()
        
        // 如果平衡值偏离中心位置，重置它
        if abs(currentBalance) > 0.001 {
            print("平衡值偏离中心 (\(currentBalance))，正在重置")
            if device.resetBalance() {
                print("成功重置平衡值到中心位置")
                DispatchQueue.main.async {
                    if isInput {
                        self.inputBalance = 0.0
                    } else {
                        self.outputBalance = 0.0
                    }
                }
            } else {
                print("重置平衡值失败")
            }
        } else {
            print("平衡值已经在中心位置: \(currentBalance)")
        }
    }
    
    // 启动蓝牙设备平衡保护系统
    private func startBalanceProtectionSystem() {
        print("启动蓝牙设备平衡保护系统")
        
        // 停止已有的定时器
        balanceProtectionTimer?.invalidate()
        balanceProtectionTimer = nil
        
        // 创建新的保护定时器，每1秒检查一次蓝牙设备平衡值
        balanceProtectionTimer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.checkAndProtectBluetoothDeviceBalance()
        }
        
        isBalanceProtectionActive = true
    }
    
    // 停止平衡保护系统
    private func stopBalanceProtectionSystem() {
        print("停止蓝牙设备平衡保护系统")
        balanceProtectionTimer?.invalidate()
        balanceProtectionTimer = nil
        isBalanceProtectionActive = false
    }
    
    // 检查并保护蓝牙设备平衡值
    private func checkAndProtectBluetoothDeviceBalance() {
        // 检查输出设备
        if let outputDevice = selectedOutputDevice, outputDevice.uid.lowercased().contains("bluetooth") {
            let currentBalance = outputDevice.getBalance()
            
            // 检查平衡值是否偏离中心位置
            if abs(currentBalance) > 0.01 && abs(currentBalance - outputBalance) > 0.01 {
                print("检测到蓝牙输出设备平衡值漂移: \(outputBalance) -> \(currentBalance)，正在修正...")
                
                // 尝试恢复到应有的平衡值
                if outputDevice.setBalance(outputBalance) {
                    print("成功恢复蓝牙输出设备平衡值到 \(outputBalance)")
                } else {
                    print("无法恢复蓝牙输出设备平衡值")
                    
                    // 如果恢复失败，尝试重置到中心位置
                    if abs(currentBalance) > 0.05 && outputDevice.resetBalance() {
                        print("已重置蓝牙输出设备平衡到中心位置")
                        outputBalance = 0.0
                    }
                }
            }
        }
        
        // 检查输入设备
        if let inputDevice = selectedInputDevice, inputDevice.uid.lowercased().contains("bluetooth") {
            let currentBalance = inputDevice.getBalance()
            
            // 检查平衡值是否偏离中心位置
            if abs(currentBalance) > 0.01 && abs(currentBalance - inputBalance) > 0.01 {
                print("检测到蓝牙输入设备平衡值漂移: \(inputBalance) -> \(currentBalance)，正在修正...")
                
                // 尝试恢复到应有的平衡值
                if inputDevice.setBalance(inputBalance) {
                    print("成功恢复蓝牙输入设备平衡值到 \(inputBalance)")
                } else {
                    print("无法恢复蓝牙输入设备平衡值")
                    
                    // 如果恢复失败，尝试重置到中心位置
                    if abs(currentBalance) > 0.05 && inputDevice.resetBalance() {
                        print("已重置蓝牙输入设备平衡到中心位置")
                        inputBalance = 0.0
                    }
                }
            }
        }
    }
} 